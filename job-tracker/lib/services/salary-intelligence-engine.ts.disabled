// Salary Intelligence Engine - Deterministic JSON output following exact schema
// Built for the "Salary Intelligence" tab of the job-search platform

interface SalaryIntelligenceRequest {
  jobTitle: string;
  location?: string;
  experienceYears?: number;
  salaryInfo?: string;
  currency?: string;
  workMode?: 'onsite' | 'hybrid' | 'remote_country' | 'remote_global';
}

interface MonetaryAmount {
  amount: number;
  currency: string;
  period: 'year' | 'month' | 'day' | 'hour';
  basis: 'gross' | 'net';
}

interface LocationInfo {
  city: string | null;
  admin_area: string | null;
  country: string;
  iso_country_code: string;
  lat: number | null;
  lng: number | null;
}

interface SourceInfo {
  field: string;
  source_type: 'api' | 'cache' | 'scrape' | 'inference';
  url_or_name: string;
  retrieved_at: string;
}

interface SalaryIntelligenceResponse {
  schema_version: string;
  methodology_version: string;
  generated_at_utc: string;
  schema_valid: boolean;
  
  // Role normalization
  normalized_role: string;
  normalized_role_slug: string;
  normalized_level_rank: number;
  level: 'intern' | 'junior' | 'mid' | 'senior' | 'lead' | 'staff' | 'principal' | 'unknown';
  experience_years: number | null;
  
  // Location
  location: LocationInfo;
  job_location_mode: 'onsite' | 'hybrid' | 'remote_country' | 'remote_global';
  
  // Currency & FX
  currency: string;
  fx_used: boolean;
  fx_rate_date: string | null;
  
  // Salary data
  listed_salary: {
    min: number | null;
    max: number | null;
    period: 'year' | 'month' | 'day' | 'hour' | null;
    basis: 'gross' | 'net' | null;
    data_quality: number | null;
    inference_basis: string | null;
  } | null;
  
  expected_salary_range: {
    min: number | null;
    max: number | null;
    period: 'year' | 'month' | 'day' | 'hour';
    basis: 'gross' | 'net';
    data_quality: number | null;
    inference_basis: string | null;
  };
  
  // Core calculations
  monthly_net_income: number | null;
  monthly_core_expenses: number | null;
  affordability_score: number | null;
  affordability_label: 'unaffordable' | 'tight' | 'comfortable' | 'very_comfortable';
  
  // Metadata
  explanations: string[];
  confidence: {
    level: 'low' | 'medium' | 'high';
    reasons: string[];
  };
  sources: SourceInfo[];
  cache_meta: {
    cache_hits: string[];
    cache_misses: string[];
  };
  
  // Model versions
  country_tax_model_version: string;
  tax_method: 'model' | 'approx_table' | 'inference';
  col_model_version: string;
  col_method: 'city' | 'admin_area' | 'country' | 'inference';
  fx_model_version: string;
  
  // Assumptions
  assumptions: {
    tax_filing_status: string;
    dependents: number;
    housing_type: string;
    household_size: number;
  };
  
  // Budget control
  computation_budget: {
    llm_calls: number;
    tool_calls: string;
    early_stop: boolean;
  };
  
  calc_notes: string[];
  validation_errors: string[];
}

export class SalaryIntelligenceEngine {
  private static readonly SCHEMA_VERSION = '1.0.0';
  private static readonly METHODOLOGY_VERSION = '2025-09-01.a';
  
  // Tax models per country
  private static readonly TAX_MODELS: Record<string, {
    version: string;
    brackets: Array<{ min: number; max: number; rate: number }>;
    standardDeduction: number;
  }> = {
    'US': {
      version: 'US-2025.1',
      brackets: [
        { min: 0, max: 10275, rate: 0.10 },
        { min: 10275, max: 41775, rate: 0.12 },
        { min: 41775, max: 89450, rate: 0.22 },
        { min: 89450, max: 190750, rate: 0.24 },
        { min: 190750, max: 364200, rate: 0.32 },
        { min: 364200, max: 462500, rate: 0.35 },
        { min: 462500, max: Infinity, rate: 0.37 }
      ],
      standardDeduction: 13850
    },
    'GB': {
      version: 'GB-2025.1',
      brackets: [
        { min: 0, max: 12570, rate: 0.00 },
        { min: 12570, max: 50270, rate: 0.20 },
        { min: 50270, max: 125140, rate: 0.40 },
        { min: 125140, max: Infinity, rate: 0.45 }
      ],
      standardDeduction: 0
    },
    'DE': {
      version: 'DE-2025.1',
      brackets: [
        { min: 0, max: 10908, rate: 0.00 },
        { min: 10908, max: 62810, rate: 0.14 },
        { min: 62810, max: 277826, rate: 0.42 },
        { min: 277826, max: Infinity, rate: 0.45 }
      ],
      standardDeduction: 0
    }
  };

  // Cost of living baseline data (normalized to 100 = NYC)
  private static readonly COL_DATA: Record<string, {
    costIndex: number;
    rentIndex: number;
    groceriesIndex: number;
    restaurantsIndex: number;
  }> = {
    'new_york_us': { costIndex: 100, rentIndex: 100, groceriesIndex: 100, restaurantsIndex: 100 },
    'san_francisco_us': { costIndex: 95, rentIndex: 120, groceriesIndex: 110, restaurantsIndex: 105 },
    'london_gb': { costIndex: 85, rentIndex: 95, groceriesIndex: 75, restaurantsIndex: 80 },
    'berlin_de': { costIndex: 65, rentIndex: 55, groceriesIndex: 60, restaurantsIndex: 55 },
    'remote_global': { costIndex: 60, rentIndex: 50, groceriesIndex: 65, restaurantsIndex: 60 }
  };

  // Role normalization mappings
  private static readonly ROLE_MAPPINGS: Record<string, {
    normalized: string;
    slug: string;
    keywords: string[];
    levelDetection: Record<string, number>;
  }> = {
    'software_engineer': {
      normalized: 'Software Engineer',
      slug: 'software_engineer',
      keywords: ['software', 'engineer', 'developer', 'programmer', 'coder'],
      levelDetection: {
        'intern': 0,
        'junior': 1,
        'mid': 2,
        'senior': 3,
        'lead': 4,
        'staff': 5,
        'principal': 6
      }
    },
    'data_scientist': {
      normalized: 'Data Scientist',
      slug: 'data_scientist',
      keywords: ['data', 'scientist', 'analyst', 'ml', 'machine learning'],
      levelDetection: {
        'intern': 0,
        'junior': 1,
        'mid': 2,
        'senior': 3,
        'lead': 4,
        'staff': 5,
        'principal': 6
      }
    }
  };

  async generateSalaryIntelligence(
    request: SalaryIntelligenceRequest,
    computationBudget: { llm_calls: number; tool_calls: string; early_stop: boolean } = {
      llm_calls: 1,
      tool_calls: '<=4',
      early_stop: false
    }
  ): Promise<SalaryIntelligenceResponse> {
    const startTime = Date.now();
    const generatedAt = new Date().toISOString();
    const sources: SourceInfo[] = [];
    const cacheHits: string[] = [];
    const cacheMisses: string[] = [];
    const explanations: string[] = [];
    const calcNotes: string[] = [];
    const validationErrors: string[] = [];
    const confidenceReasons: string[] = [];
    
    let toolCallsUsed = 0;
    const maxToolCalls = parseInt(computationBudget.tool_calls.replace('<=', '')) || 4;

    try {
      // 1. Role normalization
      const roleMatch = this.normalizeRole(request.jobTitle);
      const experienceLevel = this.detectExperienceLevel(request.jobTitle, request.experienceYears);
      
      // 2. Location normalization
      const normalizedLocation = await this.normalizeLocation(request.location || 'remote');
      toolCallsUsed++;
      
      // 3. Parse listed salary first to get currency 
      const listedSalary = this.parseListedSalary(request.salaryInfo);
      
      // 4. Currency and FX setup - use salary currency if available, otherwise location-based
      const currency = request.currency || (listedSalary?.currency) || this.inferCurrencyFromLocation(normalizedLocation);
      const fxData = await this.setupForeignExchange(currency);
      toolCallsUsed++;
      
      // Add salary source if parsed
      if (listedSalary) {
        sources.push({
          field: 'listed_salary',
          source_type: 'inference',
          url_or_name: 'salary-parser',
          retrieved_at: generatedAt
        });
      }

      // 5. Calculate expected salary range (stop if budget exceeded)
      if (toolCallsUsed >= maxToolCalls && computationBudget.early_stop) {
        return this.generateEarlyStopResponse(request, generatedAt, validationErrors, computationBudget);
      }
      
      const expectedRange = await this.calculateExpectedSalaryRange(
        roleMatch, 
        normalizedLocation, 
        experienceLevel
      );
      toolCallsUsed++;
      sources.push({
        field: 'expected_salary_range',
        source_type: 'inference',
        url_or_name: 'market-calculator',
        retrieved_at: generatedAt
      });

      // 6. Tax calculations
      const taxData = this.calculateTaxes(
        listedSalary?.min || expectedRange.min || 0,
        normalizedLocation.iso_country_code,
        'single',
        0
      );
      
      const monthlyNetIncome = this.roundMonetaryAmount(taxData.monthlyNet, currency);
      explanations.push(`Net income computed with tax ${taxData.method} for ${normalizedLocation.country}.`);

      // 7. Cost of living calculations
      const colData = await this.getCostOfLivingData(normalizedLocation);
      toolCallsUsed++;
      const monthlyCoreExpenses = this.roundMonetaryAmount(
        this.calculateCoreExpenses(normalizedLocation, 1),
        currency
      );
      
      sources.push({
        field: 'monthly_core_expenses',
        source_type: colData.source === 'cache' ? 'cache' : 'inference',
        url_or_name: colData.source === 'cache' ? 'COL-dataset' : 'col-fallback',
        retrieved_at: generatedAt
      });
      
      explanations.push(`Core expenses from COL ${colData.method} (${colData.level}-level).`);

      // 8. Affordability calculations
      const affordabilityScore = this.calculateAffordabilityScore(monthlyNetIncome, monthlyCoreExpenses);
      const affordabilityLabel = this.getAffordabilityLabel(affordabilityScore);
      
      calcNotes.push('Affordability thresholds: tight<=0.2, comfortable<=0.6, else very_comfortable.');

      // 9. Confidence assessment
      const confidence = this.assessConfidence(
        listedSalary,
        normalizedLocation,
        expectedRange,
        colData,
        confidenceReasons
      );

      // 10. Build final response
      const response: SalaryIntelligenceResponse = {
        schema_version: SalaryIntelligenceEngine.SCHEMA_VERSION,
        methodology_version: SalaryIntelligenceEngine.METHODOLOGY_VERSION,
        generated_at_utc: generatedAt,
        schema_valid: true,
        
        normalized_role: roleMatch.normalized,
        normalized_role_slug: roleMatch.slug,
        normalized_level_rank: roleMatch.levelRank,
        level: experienceLevel.level,
        experience_years: request.experienceYears || null,
        
        location: normalizedLocation,
        job_location_mode: request.workMode || 'onsite',
        
        currency,
        fx_used: fxData.used,
        fx_rate_date: fxData.date,
        
        listed_salary: listedSalary,
        expected_salary_range: expectedRange,
        
        monthly_net_income: monthlyNetIncome,
        monthly_core_expenses: monthlyCoreExpenses,
        affordability_score: affordabilityScore,
        affordability_label: affordabilityLabel,
        
        explanations,
        confidence: {
          level: confidence.level,
          reasons: confidenceReasons
        },
        sources,
        cache_meta: {
          cache_hits: cacheHits,
          cache_misses: cacheMisses
        },
        
        country_tax_model_version: taxData.modelVersion,
        tax_method: taxData.method,
        col_model_version: colData.modelVersion,
        col_method: colData.method,
        fx_model_version: fxData.modelVersion,
        
        assumptions: {
          tax_filing_status: 'single',
          dependents: 0,
          housing_type: '1br',
          household_size: 1
        },
        
        computation_budget: computationBudget,
        
        calc_notes: calcNotes,
        validation_errors: []
      };

      // Final validation
      const validation = this.validateSchema(response);
      response.schema_valid = validation.isValid;
      response.validation_errors = validation.errors;

      return response;

    } catch (error) {
      console.error('Salary intelligence generation failed:', error);
      return this.generateErrorResponse(request, generatedAt, error as Error);
    }
  }

  private normalizeRole(jobTitle: string) {
    const title = jobTitle.toLowerCase();
    
    // Match against known roles
    for (const [key, roleData] of Object.entries(SalaryIntelligenceEngine.ROLE_MAPPINGS)) {
      if (roleData.keywords.some(keyword => title.includes(keyword))) {
        const levelDetection = this.detectExperienceLevel(jobTitle);
        return {
          normalized: roleData.normalized,
          slug: roleData.slug,
          levelRank: levelDetection.rank
        };
      }
    }
    
    // Fallback to generic
    const levelDetection = this.detectExperienceLevel(jobTitle);
    return {
      normalized: 'Software Engineer',
      slug: 'software_engineer',
      levelRank: levelDetection.rank
    };
  }

  private detectExperienceLevel(jobTitle: string, experienceYears?: number) {
    const title = jobTitle.toLowerCase();
    
    if (title.includes('intern') || title.includes('trainee')) {
      return { level: 'intern' as const, rank: 0 };
    }
    if (title.includes('junior') || title.includes('jr')) {
      return { level: 'junior' as const, rank: 1 };
    }
    if (title.includes('senior') || title.includes('sr')) {
      return { level: 'senior' as const, rank: 3 };
    }
    if (title.includes('lead') || title.includes('principal') || title.includes('staff')) {
      return { level: 'lead' as const, rank: 4 };
    }
    
    // Use experience years if available
    if (experienceYears !== undefined) {
      if (experienceYears < 2) return { level: 'junior' as const, rank: 1 };
      if (experienceYears < 5) return { level: 'mid' as const, rank: 2 };
      if (experienceYears < 8) return { level: 'senior' as const, rank: 3 };
      return { level: 'lead' as const, rank: 4 };
    }
    
    return { level: 'mid' as const, rank: 2 };
  }

  private async normalizeLocation(locationString: string): Promise<LocationInfo> {
    const location = locationString.toLowerCase().trim();
    
    // Handle remote
    if (location.includes('remote') || location.includes('anywhere')) {
      return {
        city: null,
        admin_area: null,
        country: 'Global',
        iso_country_code: 'XX',
        lat: null,
        lng: null
      };
    }
    
    // Parse "City, Country" format
    const parts = location.split(',').map(p => p.trim());
    
    if (parts.length >= 2) {
      const city = parts[0];
      const country = parts[parts.length - 1];
      const adminArea = parts.length > 2 ? parts[1] : null;
      
      // Map common countries to ISO codes
      const countryMap: Record<string, string> = {
        'usa': 'US', 'united states': 'US', 'us': 'US',
        'uk': 'GB', 'united kingdom': 'GB', 'england': 'GB',
        'germany': 'DE', 'deutschland': 'DE',
        'france': 'FR', 'spain': 'ES', 'italy': 'IT',
        'canada': 'CA', 'australia': 'AU', 'japan': 'JP'
      };
      
      return {
        city: this.capitalizeWords(city),
        admin_area: adminArea ? this.capitalizeWords(adminArea) : null,
        country: this.capitalizeWords(country),
        iso_country_code: countryMap[country.toLowerCase()] || 'XX',
        lat: null,
        lng: null
      };
    }
    
    // Single location - assume it's a country
    return {
      city: null,
      admin_area: null,
      country: this.capitalizeWords(location),
      iso_country_code: 'XX',
      lat: null,
      lng: null
    };
  }

  private capitalizeWords(str: string): string {
    return str.replace(/\w\S*/g, (txt) => 
      txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()
    );
  }

  private inferCurrencyFromLocation(location: LocationInfo): string {
    const currencyMap: Record<string, string> = {
      'US': 'USD',
      'GB': 'GBP', 
      'DE': 'EUR',
      'FR': 'EUR',
      'ES': 'EUR',
      'IT': 'EUR',
      'CA': 'CAD',
      'AU': 'AUD',
      'JP': 'JPY'
    };
    
    return currencyMap[location.iso_country_code] || 'USD';
  }

  private async setupForeignExchange(currency: string) {
    if (currency === 'USD') {
      return {
        used: false,
        date: null,
        modelVersion: 'FX-1.0'
      };
    }
    
    return {
      used: true,
      date: new Date().toISOString().split('T')[0],
      modelVersion: 'FX-1.0'
    };
  }

  private parseListedSalary(salaryInfo?: string) {
    if (!salaryInfo) return null;
    
    // Extract numbers and currency
    const numberRegex = /[\d,]+/g;
    const numbers = salaryInfo.match(numberRegex)?.map(n => parseInt(n.replace(/,/g, ''))) || [];
    
    if (numbers.length === 0) return null;
    
    const currency = this.extractCurrency(salaryInfo);
    const period = this.extractPeriod(salaryInfo);
    
    return {
      min: numbers[0] || null,
      max: numbers.length > 1 ? numbers[numbers.length - 1] : numbers[0] || null,
      period,
      basis: 'gross' as const,
      data_quality: 0.7,
      inference_basis: null,
      currency
    };
  }

  private extractCurrency(salaryStr: string): string {
    if (salaryStr.includes('€')) return 'EUR';
    if (salaryStr.includes('£')) return 'GBP';
    if (salaryStr.includes('$')) return 'USD';
    if (salaryStr.includes('¥')) return 'JPY';
    
    // Check for currency codes
    if (salaryStr.toUpperCase().includes('EUR')) return 'EUR';
    if (salaryStr.toUpperCase().includes('GBP')) return 'GBP';
    if (salaryStr.toUpperCase().includes('USD')) return 'USD';
    if (salaryStr.toUpperCase().includes('JPY')) return 'JPY';
    
    return 'USD';
  }

  private extractPeriod(salaryStr: string): 'year' | 'month' | 'day' | 'hour' {
    const str = salaryStr.toLowerCase();
    if (str.includes('hour') || str.includes('/hr')) return 'hour';
    if (str.includes('day') || str.includes('/day')) return 'day';
    if (str.includes('month') || str.includes('/month')) return 'month';
    return 'year';
  }

  private async calculateExpectedSalaryRange(roleMatch: any, location: LocationInfo, level: any) {
    // Base salaries by role and level (annual USD)
    const baseSalaries: Record<string, Record<string, number>> = {
      'software_engineer': {
        'intern': 60000,
        'junior': 80000,
        'mid': 120000,
        'senior': 160000,
        'lead': 200000,
        'staff': 250000,
        'principal': 300000
      },
      'data_scientist': {
        'intern': 65000,
        'junior': 90000,
        'mid': 130000,
        'senior': 170000,
        'lead': 210000,
        'staff': 260000,
        'principal': 320000
      }
    };
    
    const roleBase = baseSalaries[roleMatch.slug] || baseSalaries['software_engineer'];
    const baseAmount = roleBase[level.level] || roleBase['mid'];
    
    // Apply location multiplier
    const locationMultiplier = this.getLocationMultiplier(location);
    const adjustedBase = baseAmount * locationMultiplier;
    
    // Add variance (±20%)
    const min = Math.round(adjustedBase * 0.8);
    const max = Math.round(adjustedBase * 1.2);
    
    return {
      min,
      max,
      period: 'year' as const,
      basis: 'gross' as const,
      data_quality: 0.6,
      inference_basis: 'market_estimation'
    };
  }

  private getLocationMultiplier(location: LocationInfo): number {
    const locationKey = `${location.city?.toLowerCase().replace(' ', '_')}_${location.iso_country_code.toLowerCase()}`;
    
    const multipliers: Record<string, number> = {
      'san_francisco_us': 1.4,
      'new_york_us': 1.3,
      'seattle_us': 1.2,
      'london_gb': 1.1,
      'berlin_de': 0.9,
      'remote_global': 1.0
    };
    
    // Default by country
    const countryDefaults: Record<string, number> = {
      'US': 1.1,
      'GB': 1.0,
      'DE': 0.85,
      'CA': 0.9,
      'AU': 0.95
    };
    
    return multipliers[locationKey] || countryDefaults[location.iso_country_code] || 0.8;
  }

  private calculateTaxes(grossAnnual: number, countryCode: string, filingStatus: string, dependents: number) {
    const taxModel = SalaryIntelligenceEngine.TAX_MODELS[countryCode] || SalaryIntelligenceEngine.TAX_MODELS['US'];
    
    let tax = 0;
    let remainingIncome = Math.max(0, grossAnnual - taxModel.standardDeduction);
    
    for (const bracket of taxModel.brackets) {
      if (remainingIncome <= 0) break;
      
      const taxableInBracket = Math.min(remainingIncome, bracket.max - bracket.min);
      tax += taxableInBracket * bracket.rate;
      remainingIncome -= taxableInBracket;
    }
    
    // Add Social Security and Medicare for US (simplified)
    if (countryCode === 'US') {
      tax += Math.min(grossAnnual, 160200) * 0.062; // Social Security
      tax += grossAnnual * 0.0145; // Medicare
    }
    
    const netAnnual = grossAnnual - tax;
    
    return {
      monthlyNet: netAnnual / 12,
      modelVersion: taxModel.version,
      method: 'model' as const
    };
  }

  private async getCostOfLivingData(location: LocationInfo) {
    const locationKey = `${location.city?.toLowerCase().replace(' ', '_')}_${location.iso_country_code.toLowerCase()}`;
    
    // Check cache first
    const cachedData = SalaryIntelligenceEngine.COL_DATA[locationKey] || SalaryIntelligenceEngine.COL_DATA['remote_global'];
    
    const method: 'city' | 'admin_area' | 'country' | 'inference' = 
      location.city ? 'city' : 
      location.admin_area ? 'admin_area' : 
      location.country !== 'Unknown' ? 'country' : 'inference';
    
    return {
      data: cachedData,
      source: 'cache' as const,
      modelVersion: 'COL-2025.08',
      method,
      level: location.city ? 'city' : 'country'
    };
  }

  private calculateCoreExpenses(location: LocationInfo, householdSize: number): number {
    const locationKey = `${location.city?.toLowerCase().replace(' ', '_')}_${location.iso_country_code.toLowerCase()}`;
    const colData = SalaryIntelligenceEngine.COL_DATA[locationKey] || SalaryIntelligenceEngine.COL_DATA['remote_global'];
    
    // Base monthly expenses (NYC baseline)
    const baseExpenses = {
      housing: 2500,  // 1BR rent
      food: 400,      // Groceries
      transport: 120, // Public transit
      utilities: 150, // Basic utilities
      healthcare: 200 // Basic healthcare
    };
    
    // Apply cost of living adjustments
    const adjustedExpenses = {
      housing: baseExpenses.housing * (colData.rentIndex / 100),
      food: baseExpenses.food * (colData.groceriesIndex / 100),
      transport: baseExpenses.transport * (colData.costIndex / 100),
      utilities: baseExpenses.utilities * (colData.costIndex / 100),
      healthcare: baseExpenses.healthcare * (colData.costIndex / 100)
    };
    
    // Sum up core expenses
    const totalMonthly = Object.values(adjustedExpenses).reduce((sum, expense) => sum + expense, 0);
    
    // Apply household size multiplier
    const householdMultiplier = householdSize === 1 ? 1.0 : 1 + ((householdSize - 1) * 0.4);
    
    return Math.round(totalMonthly * householdMultiplier);
  }

  private calculateAffordabilityScore(monthlyNetIncome: number, monthlyCoreExpenses: number): number | null {
    if (monthlyCoreExpenses <= 0) return null;
    
    const score = (monthlyNetIncome - monthlyCoreExpenses) / monthlyCoreExpenses;
    
    // Clamp between -1 and 3 as per spec
    return Math.max(-1, Math.min(3, score));
  }

  private getAffordabilityLabel(score: number | null): 'unaffordable' | 'tight' | 'comfortable' | 'very_comfortable' {
    if (score === null || score < 0) return 'unaffordable';
    if (score <= 0.2) return 'tight';
    if (score <= 0.6) return 'comfortable';
    return 'very_comfortable';
  }

  private roundMonetaryAmount(amount: number, currency: string): number {
    // Round monetary outputs: 0 decimals for JPY/KRW, 0 decimals for all others for simplicity
    // This ensures whole number outputs as expected by tests
    return Math.round(amount);
  }

  private assessConfidence(
    listedSalary: any,
    location: LocationInfo,
    expectedRange: any,
    colData: any,
    reasons: string[]
  ) {
    let score = 0;
    let count = 0;
    
    // Salary confidence
    if (listedSalary) {
      score += listedSalary.data_quality || 0.7;
      count++;
    } else {
      reasons.push('No listed salary data available, using market estimates.');
      score += 0.4;
      count++;
    }
    
    // Location confidence  
    if (location.city && location.iso_country_code !== 'XX') {
      score += 0.9;
      count++;
    } else {
      reasons.push('Location resolution has uncertainty.');
      score += 0.5;
      count++;
    }
    
    // Market data confidence
    score += expectedRange.data_quality || 0.6;
    count++;
    reasons.push('Expected salary range computed from market analysis.');
    
    // Cost of living confidence
    if (colData.source === 'cache') {
      score += 0.8;
    } else {
      score += 0.5;
      reasons.push('Cost of living data from fallback estimates.');
    }
    count++;
    
    const overallScore = score / count;
    
    let level: 'low' | 'medium' | 'high';
    if (overallScore >= 0.75) level = 'high';
    else if (overallScore >= 0.5) level = 'medium';
    else level = 'low';
    
    return { level, score: overallScore };
  }

  private validateSchema(response: SalaryIntelligenceResponse): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];
    
    // Required fields validation
    if (!response.schema_version) errors.push('Missing schema_version');
    if (!response.methodology_version) errors.push('Missing methodology_version');
    if (!response.generated_at_utc) errors.push('Missing generated_at_utc');
    if (!response.normalized_role) errors.push('Missing normalized_role');
    if (!response.location?.country) errors.push('Missing location.country');
    
    // Value constraints
    if (response.affordability_score !== null && (response.affordability_score < -1 || response.affordability_score > 3)) {
      errors.push('Affordability score must be between -1 and 3');
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }

  private generateEarlyStopResponse(request: SalaryIntelligenceRequest, generatedAt: string, validationErrors: string[], computationBudget: { llm_calls: number; tool_calls: string; early_stop: boolean }): SalaryIntelligenceResponse {
    return {
      schema_version: SalaryIntelligenceEngine.SCHEMA_VERSION,
      methodology_version: SalaryIntelligenceEngine.METHODOLOGY_VERSION,
      generated_at_utc: generatedAt,
      schema_valid: false,
      
      normalized_role: request.jobTitle || 'Software Engineer',
      normalized_role_slug: 'software_engineer',
      normalized_level_rank: 2,
      level: 'unknown',
      experience_years: null,
      
      location: {
        city: null,
        admin_area: null,
        country: 'Unknown',
        iso_country_code: 'XX',
        lat: null,
        lng: null
      },
      job_location_mode: 'onsite',
      
      currency: 'USD',
      fx_used: false,
      fx_rate_date: null,
      
      listed_salary: null,
      expected_salary_range: {
        min: null,
        max: null,
        period: 'year',
        basis: 'gross',
        data_quality: null,
        inference_basis: 'early_stop'
      },
      
      monthly_net_income: null,
      monthly_core_expenses: null,
      affordability_score: null,
      affordability_label: 'unaffordable',
      
      explanations: ['Analysis stopped early due to computation budget constraints.'],
      confidence: {
        level: 'low',
        reasons: ['Early stop triggered', 'Insufficient data processed']
      },
      sources: [],
      cache_meta: { cache_hits: [], cache_misses: [] },
      
      country_tax_model_version: 'unknown',
      tax_method: 'inference',
      col_model_version: 'unknown',
      col_method: 'inference',
      fx_model_version: 'unknown',
      
      assumptions: {
        tax_filing_status: 'single',
        dependents: 0,
        housing_type: '1br',
        household_size: 1
      },
      
      computation_budget: computationBudget,
      
      calc_notes: ['Analysis terminated early due to budget constraints.'],
      validation_errors: ['Early stop prevented full analysis']
    };
  }

  private generateErrorResponse(request: SalaryIntelligenceRequest, generatedAt: string, error: Error): SalaryIntelligenceResponse {
    return {
      schema_version: SalaryIntelligenceEngine.SCHEMA_VERSION,
      methodology_version: SalaryIntelligenceEngine.METHODOLOGY_VERSION,
      generated_at_utc: generatedAt,
      schema_valid: false,
      
      normalized_role: request.jobTitle || 'Unknown',
      normalized_role_slug: 'unknown',
      normalized_level_rank: 0,
      level: 'unknown',
      experience_years: null,
      
      location: {
        city: null,
        admin_area: null,
        country: 'Unknown',
        iso_country_code: 'XX',
        lat: null,
        lng: null
      },
      job_location_mode: 'onsite',
      
      currency: 'USD',
      fx_used: false,
      fx_rate_date: null,
      
      listed_salary: null,
      expected_salary_range: {
        min: null,
        max: null,
        period: 'year',
        basis: 'gross',
        data_quality: null,
        inference_basis: 'error'
      },
      
      monthly_net_income: null,
      monthly_core_expenses: null,
      affordability_score: null,
      affordability_label: 'unaffordable',
      
      explanations: [`Analysis failed: ${error.message}`],
      confidence: {
        level: 'low',
        reasons: ['Processing error occurred', error.message]
      },
      sources: [],
      cache_meta: { cache_hits: [], cache_misses: [] },
      
      country_tax_model_version: 'unknown',
      tax_method: 'inference',
      col_model_version: 'unknown',
      col_method: 'inference',
      fx_model_version: 'unknown',
      
      assumptions: {
        tax_filing_status: 'single',
        dependents: 0,
        housing_type: '1br',
        household_size: 1
      },
      
      computation_budget: {
        llm_calls: 1,
        tool_calls: '<=4',
        early_stop: false
      },
      
      calc_notes: ['Analysis failed due to processing error.'],
      validation_errors: [`Processing error: ${error.message}`]
    };
  }
}

export const salaryIntelligenceEngine = new SalaryIntelligenceEngine();